<!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta name="baidu-site-verification" content="kZmc8XTvrB"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?458cfc1440d057b6b8799400c6b2e2bf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta charset="utf-8"><title>机器学习（二）基本数据类型 | 机器学习 and 数据科学</title><meta name="author" content="王小鹏  京ICP备19037345号-1"><meta name="keywords" content="PDF电子书下载,电子书，PDF下载"><meta name="description" content="PDF电子书下载,电子书，PDF下载"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="机器学习（二）基本数据类型"><meta property="og:site_name" content="机器学习 and 数据科学"><meta property="og:image" content><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="机器学习 and 数据科学" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body><header id="header" class="inner"><div class="alignleft"><h1><a href="/">机器学习 and 数据科学</a></h1><h2><a href="/">明天幸福今天修</a></h2></div><nav id="main-nav" class="alignright"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div id="content" class="inner"><div id="main-col" class="alignleft"><div id="wrapper"><article id="post-ml-ml2" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="post-content"><header><div class="icon"></div><time class="dt-published" datetime="2019-08-29T07:32:39.000Z"><a href="/machinelearning/ml-ml2/">2019-08-29</a><span id="busuanzi_container_page_pv"> &nbsp;&nbsp;&nbsp;&nbsp;阅读 <span id="busuanzi_value_page_pv"></span></span></time><h1 class="p-name title" itemprop="headline name">机器学习（二）基本数据类型</h1></header><div class="e-content entry" itemprop="articleBody"><p>标签： machine learning<br><img src="/machinelearning/ml-ml2/1.png" alt="图1"></p><a id="more"></a><p>MLlib支持存储在单个机器上的局部向量和矩阵，以及由一个或多个RDD支持的分布式矩阵。 局部向量和局部矩阵是用作公共接口的简单数据模型。 底层线性代数操作由Breeze提供。 在监督学习中使用的训练示例在MLlib中称为“标记点”。</p><h1 id="一、本地向量"><a href="#一、本地向量" class="headerlink" title="一、本地向量"></a><strong>一、本地向量</strong></h1><p>局部向量具有整数类型和基于0的索引和双类型值，存储在单个机器上。 MLlib支持两种类型的局部向量：密集和稀疏。 密集向量由表示其条目值的双数组支持，而稀疏向量由两个并行数组支持：索引和值。 例如，矢量（1.0,0.0,3.0）可以以密集格式表示为[1.0,0.0,3.0]，或者以稀疏格式表示为（3，[0,2]，[1.0,3.0]），其中3是 矢量的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建一个稠密本地向量</span><br><span class="line">Vector v1 = Vectors.dense(0.0, 10.0, 0.5);</span><br><span class="line">//创建一个稀疏向量</span><br><span class="line">Vector v2 = Vectors.sparse(3, new int[]&#123;0, 1&#125;, new  double[]&#123;-2.0, 2.3&#125;);</span><br></pre></td></tr></table></figure><h1 id="二、向量标签（标记点）（LabeledPoint）"><a href="#二、向量标签（标记点）（LabeledPoint）" class="headerlink" title="二、向量标签（标记点）（LabeledPoint）"></a><strong>二、向量标签（标记点）（LabeledPoint）</strong></h1><p>向量标签LabeledPoint是一种带有标签（Label/Response）的本地向量，它可以是稠密或者是稀疏的。 在MLlib中，标记点用于监督学习算法。由于标签是用双精度浮点型来存储的，故标注点类型在回归（Regression）和分类（Classification）问题上均可使用。例如，对于二分类问题，则正样本的标签为1，负样本的标签为0，而对于多类别的分类问题来说，标签则应是一个以0开始的索引序列:0, 1, 2 …</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建一个标签为1.0（分类中可视为正样本）的稠密向量标注点</span><br><span class="line">LabeledPoint L1 = new LabeledPoint(1.0,Vectors.dense(2.0, 3.0, 3.0));</span><br><span class="line">//创建一个标签为0.0（分类中可视为负样本）的稀疏向量标注点</span><br><span class="line">LabeledPoint L2 = new LabeledPoint(0.0,Vectors.sparse(3, new int[]&#123;0, 1&#125;, new  double[]&#123;-2.0, 2.3&#125;));</span><br></pre></td></tr></table></figure><p>在实际的机器学习问题中，稀疏向量数据是非常常见的，MLlib提供了读取LIBSVM格式数据的支持，该格式被广泛用于LIBSVM、LIBLINEAR等机器学习库。在该格式下，每一个带标注的样本点由以下格式表示：</p><pre><code>label    index1:value1   index2:value2   index3:value3  ...</code></pre><p>其中label是该样本点的标签值，一系列index:value对则代表了该样本向量中所有非零元素的索引和元素值。这里需要特别注意的是，index是以1开始并递增的。 MLlib在org.apache.spark.mllib.util.MLUtils工具类中提供了读取LIBSVM格式的方法loadLibSVMFile，其使用非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SparkSession spark = SparkSession.builder().appName(&quot;VectorsTest&quot;).master(&quot;local[2]&quot;).getOrCreate();</span><br><span class="line">SparkContext sparkContext = spark.sparkContext();</span><br><span class="line">JavaRDD&lt;LabeledPoint&gt; examples=MLUtils.loadLibSVMFile(sparkContext,&quot;data/mllib/sample_libsvm_data.txt&quot;).toJavaRDD();</span><br><span class="line"></span><br><span class="line">(0.0,(692,[127,128,129,130,131,154,155,156,157,158,159,181,182,183,184,185,186,187,188,189,207,208,209,210,211,212,213,214,</span><br><span class="line">215,216,217,235,236,237,238,239,240,241,242,243,244,245,262,263,264,265,266,267,268,269,270,271,272,273,289,290,291,292,293,</span><br><span class="line">294,295,296,297,300,301,302,316,317,318,319,320,321,328,329,330,343,344,345,346,347,348,349,356,357,358,371,372,373,374,384,</span><br><span class="line">385,386,399,400,401,412,413,414,426,427,428,429,440,441,442,454,455,456,457,466,467,468,469,470,482,483,484,493,494,495,496,</span><br><span class="line">497,510,511,512,520,521,522,523,538,539,540,547,548,549,550,566,567,568,569,570,571,572,573,574,575,576,577,578,594,595,596,</span><br><span class="line">597,598,599,600,601,602,603,604,622,623,624,625,626,627,628,629,630,651,652,653,654,655,656,657],[51.0,159.0,253.0,159.0,50...</span><br></pre></td></tr></table></figure><p>每个标注点共有692个维，其中第127列对应的值是51.0，第128列对应的值是159.0，依此类推。</p><h1 id="三、本地矩阵"><a href="#三、本地矩阵" class="headerlink" title="三、本地矩阵"></a><strong>三、本地矩阵</strong></h1><p>局部矩阵具有整数类型的行和列索引以及双类型值，存储在单个机器上。 MLlib支持密集矩阵，其条目值以列主要顺序存储在单个双数组中，以及稀疏矩阵，其非零条目值以列主要顺序存储在压缩稀疏列（CSC）格式中。 例如，以下密集矩阵：</p><p><img src="/machinelearning/ml-ml2/2.png" alt="图2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建稠密矩阵((1.0, 2.0), (3.0, 4.0), (5.0, 6.0))</span><br><span class="line">Matrix d = Matrices.dense(3, 2, new  double[]&#123;1.0, 3.0, 5.0, 2.0, 4.0, 6.0&#125;);</span><br><span class="line">//创建稀疏矩阵((9.0, 0.0), (0.0, 8.0), (0.0, 6.0))</span><br><span class="line">Matrix s = Matrices.sparse(3, 2, new  int[]&#123;0, 1,3&#125;, new int[]&#123;0, 1,1&#125;, new  double[]&#123;9.0, 6.0,8.0&#125;);</span><br></pre></td></tr></table></figure><p>这里，创建一个3行2列的稀疏矩阵[ [9.0,0.0], [0.0,8.0], [0.0,6.0]]。Matrices.sparse的参数中，3表示行数，2表示列数。第1个数组参数表示列指针，即每一列元素的开始索引值， 第二个数组参数表示行索引，即对应的元素是属于哪一行；第三个数组即是按列先序排列的所有非零元素，通过列指针和行索引即可判断每个元素所在的位置。比如取每个数组的第2个元素为2,1,6，表示第2列第1行的元素值是6.0。</p><h1 id="四、分布式矩阵"><a href="#四、分布式矩阵" class="headerlink" title="四、分布式矩阵"></a><strong>四、分布式矩阵</strong></h1><p>分布式矩阵具有长类型的行和列索引以及双类型值，分布式地存储在一个或多个RDD中。选择正确的格式来存储大型和分布式矩阵非常重要。将分布式矩阵转换为不同的格式可能需要全局混洗，这非常昂贵。到目前为止已经实现了四种类型的分布式矩阵。</p><p>基本类型称为RowMatrix。 RowMatrix是行方向的分布式矩阵，没有有意义的行索引，例如特征向量的集合。它由行的RDD支持，其中每行是本地向量。我们假设RowMatrix的列数不是很大，因此单个本地向量可以合理地传递给驱动程序，也可以使用单个节点进行存储/操作。 IndexedRowMatrix类似于RowMatrix，但具有行索引，可用于标识行和执行连接。 CoordinateMatrix是以坐标列表（COO）格式存储的分布式矩阵，由其条目的RDD支持。 BlockMatrix是由MatrixBlock的RDD支持的分布式矩阵，它是（Int，Int，Matrix）的元组。</p><h2 id="4-1、行矩阵（RowMatrix）"><a href="#4-1、行矩阵（RowMatrix）" class="headerlink" title="4.1、行矩阵（RowMatrix）"></a><strong>4.1、行矩阵（RowMatrix）</strong></h2><p>RowMatrix是面向行的分布式矩阵，没有有意义的行索引，由其行的RDD支持，其中每行是本地向量。 由于每一行都由局部向量表示，因此列数受整数范围的限制，但在实践中它应该小得多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SparkConf conf = new  SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;DistributedMatrixRowMatrix&quot;); </span><br><span class="line">JavaSparkContext jsc = new  JavaSparkContext(conf); </span><br><span class="line">JavaRDD&lt;Vector&gt; rows =  jsc.parallelize(Arrays.asList(Vectors.dense(4.0,5.0,6.0),Vectors.dense(2.0,12.0,6.0)));</span><br><span class="line">RowMatrix matrix = new  RowMatrix(rows.rdd()); </span><br><span class="line">System.out.println(matrix.numCols()); </span><br><span class="line">System.out.println(matrix.numRows());</span><br><span class="line">System.out.println(matrix.rows().first());</span><br><span class="line">System.out.println(&quot;行数:&quot;+matrix.computeColumnSummaryStatistics().count()); </span><br><span class="line">System.out.println(&quot;最大向量:&quot;+matrix.computeColumnSummaryStatistics().max());</span><br><span class="line">System.out.println(&quot;方差向量:&quot;+matrix.computeColumnSummaryStatistics().variance()); </span><br><span class="line">System.out.println(&quot;L1范数向量:&quot;+matrix.computeColumnSummaryStatistics().normL1());</span><br></pre></td></tr></table></figure><p>在获得RowMatrix的实例后，我们可以通过其自带的computeColumnSummaryStatistics()方法获取该矩阵的一些统计摘要信息，并可以对其进行QR分解，SVD分解和PCA分解，这一部分内容将在特征降维的章节详细解说，这里不再叙述。</p><h2 id="4-2、索引行矩阵（IndexedRowMatrix）"><a href="#4-2、索引行矩阵（IndexedRowMatrix）" class="headerlink" title="4.2、索引行矩阵（IndexedRowMatrix）"></a><strong>4.2、索引行矩阵（IndexedRowMatrix）</strong></h2><p>IndexedRowMatrix类似于RowMatrix但具有有意义的行索引。 它由索引行的RDD支持，因此每行由其索引（long-typed）和本地向量表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;IndexedRow&gt; rows2 =  jsc.parallelize(Arrays.asList(new IndexedRow(1,  Vectors.dense(1.0, 2.3, 2.6)), new IndexedRow  (2, Vectors.dense(1.0,2.3,50.6))));</span><br><span class="line">IndexedRowMatrix mat2 =  new  IndexedRowMatrix(rows2.rdd());</span><br></pre></td></tr></table></figure><h2 id="4-3、坐标矩阵（Coordinate-Matrix）"><a href="#4-3、坐标矩阵（Coordinate-Matrix）" class="headerlink" title="4.3、坐标矩阵（Coordinate Matrix）"></a><strong>4.3、坐标矩阵（Coordinate Matrix）</strong></h2><p>CoordinateMatrix是由其条目的RDD支持的分布式矩阵。 每个条目都是（i：Long，j：Long，value：Double）的元组，其中i是行索引，j是列索引，value是条目值。 只有当矩阵的两个维度都很大且矩阵非常稀疏时，才应使用CoordinateMatrix。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;MatrixEntry&gt; rows3 =  jsc.parallelize(Arrays.asList(new  MatrixEntry(0,0,1.0), new MatrixEntry  (1,0,2.0)));</span><br><span class="line">CoordinateMatrix mat3 = new  CoordinateMatrix(rows3.rdd());</span><br></pre></td></tr></table></figure><h2 id="4-4、分块矩阵（Block-Matrix）"><a href="#4-4、分块矩阵（Block-Matrix）" class="headerlink" title="4.4、分块矩阵（Block Matrix）"></a><strong>4.4、分块矩阵（Block Matrix）</strong></h2><p>BlockMatrix是由MatrixBlocks的RDD支持的分布式矩阵，其中MatrixBlock是（（Int，Int），Matrix）的元组，其中（Int，Int）是块的索引，而Matrix是子 - 给定索引处的矩阵，其大小为rowsPerBlock x colsPerBlock。 BlockMatrix支持添加和乘以另一个BlockMatrix等方法。 BlockMatrix还有一个辅助函数validate，可用于检查BlockMatrix是否设置正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;MatrixEntry&gt; rows4 =  jsc.parallelize(Arrays.asList(new  MatrixEntry(0,0,1.0), new MatrixEntry  (1,0,2.0)));</span><br><span class="line">CoordinateMatrix mat = new  CoordinateMatrix(rows4.rdd());</span><br><span class="line">BlockMatrix matA =  mat.toBlockMatrix().cache();</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><ul><li><a href="http://spark.apache.org/docs/latest/mllib-data-types.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/mllib-data-types.html</a></li></ul></div><footer><div class="categories"><a href="/categories/machinelearning/">机器学习</a></div><div class="tags"><a href="/tags/content/">content</a>, <a href="/tags/machine-learning/">machine learning</a></div><div class="addthis addthis_toolbox addthis_default_style"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a> <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a> <a class="addthis_counter addthis_pill_style"></a></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script><div class="clearfix"></div></footer></div></article><section id="comment"><h1 class="title">留言</h1><div id="fb-root"></div><script>!function(e,t,n){var a,c=e.getElementsByTagName(t)[0];e.getElementById(n)||((a=e.createElement(t)).id=n,a.src="//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345",c.parentNode.insertBefore(a,c))}(document,"script","facebook-jssdk")</script><div class="fb-comments" data-href="http://www.wangpengcufe.com/machinelearning/ml-ml2/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div></section></div></div><aside id="sidebar" class="alignright"><script language="javascript">function search(e){return e.method="get",e.action="http://www.baidu.com/baidu",document.search_form.word.value=document.search_form.word.value,!0}</script><div class="search"><form name="search_form" target="_blank" onsubmit="search(this)"><input type="search" name="word" results="0" placeholder="百度站内搜索" onblur='this.value=""'></form></div><div class="widget tag"><h3 class="title">分类</h3><ul class="entry"><li><a href="/categories/read/">read</a><small>63</small></li><li><a href="/categories/tools/">工具</a><small>2</small></li><li><a href="/categories/machinelearning/">机器学习</a><small>13</small></li><li><a href="/categories/navigate/">菜单导航</a><small>1</small></li><li><a href="/categories/datadownload/">资料下载</a><small>1</small></li></ul></div><div class="widget tag"><h3 class="title">标签</h3><ul class="entry"><li><a href="/tags/content/">content</a><small>77</small></li><li><a href="/tags/library/">library</a><small>1</small></li><li><a href="/tags/machine-learning/">machine learning</a><small>13</small></li><li><a href="/tags/navigate/">navigate</a><small>1</small></li><li><a href="/tags/tools/">tools</a><small>2</small></li></ul></div><div class="widget tag"><h3 class="title">友情链接</h3><ul class="entry"><li><a href="http://blog.didispace.com" title="程序员DD">程序员DD</a></li><li><a href="https://mangoroom.cn" title="芒果的个人博客">芒果的个人博客</a></li><li><a href="http://www.baimin.com" target="_blank">百鸣网站百科</a></li><li><a href="http://blog.sina.com.cn/u/2435344920" target="_blank">默默读书</a></li><li><a href="https://www.jianshu.com/u/510007ddad06" target="_blank">王小鹏的随笔</a></li><li><a href="https://me.csdn.net/weixin_42438712" target="_blank">wangpengcufe的csdn博客</a></li><li><a href="http://meixiaohan.com/" target="_blank">小寒大人的blog</a></li></ul></div></aside><div class="clearfix"></div></div><footer id="footer" class="inner"><div class="alignleft">&copy; 2019 王小鹏 京ICP备19037345号-1</div><div class="clearfix"></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></footer><script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">jQuery(".fancybox").fancybox()</script></body></html>