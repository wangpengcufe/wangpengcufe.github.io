<!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta name="baidu-site-verification" content="kZmc8XTvrB"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?458cfc1440d057b6b8799400c6b2e2bf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta charset="utf-8"><title>python机器学习（六）回归算法-逻辑回归 | 机器学习 and 数据科学</title><meta name="author" content="王小鹏  京ICP备19037345号-1"><meta name="keywords" content="机器学习,回归算法,逻辑回归 PDF电子书下载,电子书，PDF下载"><meta name="description" content="PDF电子书下载,电子书，PDF下载"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="python机器学习（六）回归算法-逻辑回归"><meta property="og:site_name" content="机器学习 and 数据科学"><meta property="og:image" content><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="机器学习 and 数据科学" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body><header id="header" class="inner"><div class="alignleft"><h1><a href="/">机器学习 and 数据科学</a></h1><h2><a href="/">明天幸福今天修</a></h2></div><nav id="main-nav" class="alignright"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div id="content" class="inner"><div id="main-col" class="alignleft"><div id="wrapper"><article id="post-pythonml-pythonml6" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="post-content"><header><div class="icon"></div><time class="dt-published" datetime="2020-05-26T03:10:16.000Z"><a href="/machinelearning/pythonml-pythonml6/">2020-05-26</a><span id="busuanzi_container_page_pv"> &nbsp;&nbsp;&nbsp;&nbsp;阅读 <span id="busuanzi_value_page_pv"></span></span></time><h1 class="p-name title" itemprop="headline name">python机器学习（六）回归算法-逻辑回归</h1></header><div class="e-content entry" itemprop="articleBody"><p><img src="https://upload-images.jianshu.io/upload_images/7289495-940664013c6d1e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="逻辑回归"></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p>是一种名为“回归”的线性分类器，是由线性回归变化而来的，一种广泛使用于分类问题中的广义回归算法。</p><h3 id="1-2、按预测标签的数据类型分"><a href="#1-2、按预测标签的数据类型分" class="headerlink" title="1.2、按预测标签的数据类型分"></a>1.2、按预测标签的数据类型分</h3><p><strong>连续型变量：</strong>通过线性回归方程z，线性回归使用输入的特征矩阵X来输出一组连续型的标签值y_pred，以完成各种预测连续型变量的任务（比如预测产品销量，预测股价等等）<br><strong>离散型变量：</strong>通过Sigmoid函数变换，线性回归方程z变换为g(z)，使得模型的值分布在(0,1)之间，且当g(z)接近0时样本的标签为类别0，当g(z)接近1时样本的标签为类别1，这样就得到了一个分类模型。<br><img src="https://upload-images.jianshu.io/upload_images/7289495-159f757a5e841d36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性回归方程式"></p><h3 id="1-3、公式"><a href="#1-3、公式" class="headerlink" title="1.3、公式"></a>1.3、公式</h3><p><img src="https://upload-images.jianshu.io/upload_images/7289495-1e1c750ff21cbfb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式"><br>其中，y(x)就是我们逻辑回归返回的标签值。</p><h3 id="1-4、本质"><a href="#1-4、本质" class="headerlink" title="1.4、本质"></a>1.4、本质</h3><p>y（x）的形似几率取对数就是线性回归，对数几率回归，就是逻辑回归。</p><h1 id="二、重要概念"><a href="#二、重要概念" class="headerlink" title="二、重要概念"></a>二、重要概念</h1><p><strong>Sigmoid函数：</strong>Sigmoid函数是一个S型的函数，当自变量z趋近正无穷时，因变量g(z)趋近于1，而当z趋近负无穷时，g(z)趋近于0，它能够将任何实数映射到(0,1)区间，使其可用于将任意值函数转换为更适合二分类的函数。<br><img src="https://upload-images.jianshu.io/upload_images/7289495-165e4c1e50e98d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sigmoid函数"><br><img src="https://upload-images.jianshu.io/upload_images/7289495-85d129a5b0174de1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sigmoid函数公式"></p><p>因为这个性质，Sigmoid函数也被当作是归一化的一种方法，与我们之前学过的MinMaxSclaer同理，是属于数据预处理中的“缩放”功能，可以将数据压缩到[0,1]之内。区别在于，MinMaxScaler归一化之后，是可以取到0和1的（最大值归一化后就是1，最小值归一化后就是0），但Sigmoid函数只是无限趋近于0和1。</p><p><strong>损失函数：</strong>是一个评估指标，来衡量参数为 的模型拟合训练集时产生的信息损失的大小，并以此衡量参数的优劣。<br>损失函数小，模型在训练集上表现优异，拟合充分，参数优秀。<br>损失函数大，模型在训练集上表现差劲，拟合不足，参数糟糕。<br>我们追求，能够让损失函数最小化的参数组合。<br>注意：没有”求解参数“需求的模型没有损失函数，比如KNN，决策树。</p><p><img src="https://upload-images.jianshu.io/upload_images/7289495-b889f4a23e6b3caa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="损失函数公式"><br>θ表示求解出来的一组参数，m是样本的个数， y<sub>i</sub> 是样本 i 上真实的标签， y<sub>θ</sub>(x<sub>i</sub>)是样本 i 上，基于参数θ计算出来的逻辑回归返回值，x<sub>i</sub> 是样本 i 各个特征的取值。我们的目标，就是求解出使 J(<sub>θ</sub>)最小的 θ 取值。注意，在逻辑回归的本质函数y(x)里，特征矩阵x是自变量，参数是 θ。但在损失函数中，参数θ是损失函数的自变量，x和y都是已知的特征矩阵和标签，相当于是损失函数的参数。不同的函数中，自变量和参数各有不同，因此大家需要在数学计算中，尤其是求导的时候避免混淆。</p><h1 id="三、sklearn中的逻辑回归"><a href="#三、sklearn中的逻辑回归" class="headerlink" title="三、sklearn中的逻辑回归"></a>三、sklearn中的逻辑回归</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">linear_model.LogisticRegression 逻辑回归分类器（又叫logit回归，最大熵分类器</span><br><span class="line">linear_model.SGDClassifier 利用梯度下降求解的线性分类器（SVM，逻辑回归等等）</span><br><span class="line">linear_model.SGDRegressor 利用梯度下降最小化正则化后的损失函数的线性回归模型</span><br><span class="line"></span><br><span class="line">metrics.log_loss 对数损失，又称逻辑损失或交叉熵损失</span><br><span class="line">metrics.confusion_matrix 混淆矩阵，模型评估指标之一</span><br><span class="line">metrics.roc_auc_score ROC曲线，模型评估指标之一</span><br><span class="line">metrics.accuracy_score 精确性，模型评估指标之一</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sklearn.linear_model.LogisticRegression(penalty=&apos;l2&apos;, C = 1.0)</span><br><span class="line">Logistic: 回归分类器</span><br><span class="line">coef_：回归系数</span><br></pre></td></tr></table></figure><h1 id="四、重要参数"><a href="#四、重要参数" class="headerlink" title="四、重要参数"></a>四、重要参数</h1><p><strong>正则化参数, penalty&amp;C：</strong></p><p><strong>正则化：</strong> 是用来防止模型过拟合的过程，常用的有L1正则化和L2正则化两种选项，分别通过在损失函数后加上参数向量 的L1范式和L2范式的倍数来实现。这个增加的范式，被称为“正则项”，也被称为”惩罚项”。</p><p><strong>penalty:</strong> 可以输入”l1”或”l2”来指定使用哪一种正则化方式，不填写默认”l2”。<br>注意，若选择”l1”正则化，参数solver仅能够使用求解方式”liblinear”和”saga“，若使用“l2”正则化，参数solver中所有的求解方式都可以使用。</p><p><strong>C：</strong>C正则化强度的倒数，必须是一个大于0的浮点数，不填写默认1.0，即默认正则项与损失函数的比值是1：1。C越小，损失函数会越小，模型对损失函数的惩罚越重，正则化的效力越强，参数会逐渐被压缩得越来越小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># L1正则化和L2正则化的比较</span><br><span class="line">from sklearn.linear_model import LogisticRegression as LR</span><br><span class="line">from sklearn.datasets import load_breast_cancer</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.metrics import accuracy_score</span><br><span class="line">data = load_breast_cancer()</span><br><span class="line">X = data.data</span><br><span class="line">y = data.target</span><br><span class="line">data.data.shape</span><br><span class="line">lrl1 = LR(penalty=&quot;l1&quot;,solver=&quot;liblinear&quot;,C=0.5,max_iter=1000)</span><br><span class="line">lrl2 = LR(penalty=&quot;l2&quot;,solver=&quot;liblinear&quot;,C=0.5,max_iter=1000)</span><br><span class="line">#逻辑回归的重要属性coef_，查看每个特征所对应的参数</span><br><span class="line">lrl1 = lrl1.fit(X,y)</span><br><span class="line">lrl1.coef_</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7289495-75beced1ec812cad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lrl1.coef_输出结果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lrl1.coef_ != 0).sum(axis=1)</span><br><span class="line">lrl2 = lrl2.fit(X,y)</span><br><span class="line">lrl2.coef_</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7289495-38f391801c55dd58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lrl2.coef_输出结果"><br><strong>结论：</strong>L1正则化会将参数压缩为0，L2正则化只会让参数尽量小，不会取到0。</p><p><strong>max_iter：</strong><br>逻辑回归的数学目的是求解能够让模型最优化，拟合程度最好的参数的值，即求解能够让损失函数 最小化的值。对于二元逻辑回归来说，有多种方法可以用来求解参数 ，最著名的是梯度下降法(Gradient Descent)。<br><img src="https://upload-images.jianshu.io/upload_images/7289495-c3f23e1bcb4b517b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="梯度下降法"></p><p>在这个图像上随机放一个小球，当我松手，这个小球就会顺着这个华丽的平面滚落，直到滚到深蓝色的区域——损失函数的最低点。为了严格监控这个小球的行为，我让小球每次滚动的距离有限，不让他一次性滚到最低点，并且最多只允许它滚动100步，还要记下它每次滚动的方向，直到它滚到图像上的最低点。</p><p>可以看见，小球从高处滑落，在深蓝色的区域中来回震荡，最终停留在了图像凹陷处的某个点上。非常明显，我们可以观察到几个现象：</p><p>首先，小球并不是一开始就直向着最低点去的，它先一口气冲到了蓝色区域边缘，后来又折回来，我们已经规定了小球是多次滚动，所以可见，小球每次滚动的方向都是不同的。</p><p>另外，小球在进入深蓝色区域后，并没有直接找到某个点，而是在深蓝色区域中来回震荡了数次才停下。这有两种可能：1) 小球已经滚到了图像的最低点，所以停下了，2) 由于我设定的步数限制，小球还没有找到最低点，但也只好在100步的时候停下了。也就是说，小球不一定滚到了图像的最低处。</p><p>小球其实就是一组组的坐标点（θ<sub>1</sub>，θ<sub>2</sub>，J） ；小球每次滚动的方向就是那一个坐标点的梯度向量的方向，因为每滚动一步，小球所在的位置都发生变化，坐标点和坐标点对应的梯度向量都发生了变化，所以每次滚动的方向也都不一样；人为设置的100次滚动限制，就是sklearn中逻辑回归的参数max_iter，代表着能走的最大步数，即最大迭代次数。</p><p><strong>solver:</strong><br>sklearn为我们提供了多种求解逻辑回归参数θ 的方法（梯度下降法是其中著名的一种），让我们可以使用不同的求解器来计算逻辑回归。求解器的选择，由参数”solver”控制，共有五种选择。其中“liblinear”是二分类专用，也是现在的默认求解器。</p><ul><li>liblinear : 坐标下降法</li><li>lbfgs：拟牛顿法的一种，利用损失函数二阶导数矩阵（海森矩阵）来迭代优化损失函数。</li><li>newton-cg : 牛顿法的一种，利用损失函数二阶导数矩阵（海森矩阵）来迭代优化损失函数。</li><li>sag ：随机平均梯度下降，与普通梯度下降法的区别是每次迭代仅仅用一部分的样本来计算梯度。</li><li>saga：随机平均梯度下降的进化，稀疏多项逻辑回归的首选。</li></ul><p><strong>multi_class：</strong><br>输入”ovr”, “multinomial”, “auto”来告知模型，我们要处理的分类问题的类型。默认是”ovr”。</p><ul><li>‘ovr’:表示分类问题是二分类，或让模型使用”一对多”的形式来处理多分类问题。</li><li>‘multinomial’：表示处理多分类问题，这种输入在参数solver是’liblinear’时不可用。</li><li>“auto”：表示会根据数据的分类情况和其他参数来确定模型要处理的分类问题的类型。比如说，如果数据是二分<br>类，或者solver的取值为”liblinear”，”auto”会默认选择”ovr”。反之，则会选择”nultinomial”。</li></ul><p><strong>样本不平衡参数class_weight:</strong><br>样本不平衡是指在一组数据集中，标签的一类天生占有很大的比例，或误分类的代价很高，即我们想要捕捉出某种特定的分类的时候的状况。</p><p>例如：银行要判断“一个新客户是否会违约”，通常不违约的人vs违约的人会是99：1的比例，真正违约的人其实是非常少的。这种分类状况下，即便模型什么也不做，全把所有人都当成不会违约的人，正确率也能有99%，这使得模型评估指标变得毫无意义，根本无法达到我们的“要识别出会违约的人”的建模目的。</p><p>因此我们要使用参数class_weight对样本标签进行一定的均衡，给少量的标签更多的权重，让模型更偏向少数类，向捕获少数类的方向建模。该参数默认None，此模式表示自动给与数据集中的所有标签相同的权重，即自动1：1。当误分类的代价很高的时候，我们使用”balanced“模式，我们只是希望对标签进行均衡的时候，什么都不填就可以解决样本不均衡问题。</p><h1 id="五、案例介绍"><a href="#五、案例介绍" class="headerlink" title="五、案例介绍"></a>五、案例介绍</h1><p><strong>5.1、数据描述</strong><br>（1）699条样本，共11列数据，第一列用语检索的id，后9列分别是与肿瘤相关的医学特征，最后一列表示肿瘤类型的数值。<br>（2）包含16个缺失值，用”?”标出。</p><p>原始数据的下载地址：<br><a href="https://archive.ics.uci.edu/ml/machine-learning-databases/" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/machine-learning-databases/</a></p><p><strong>5.2、特征选择：</strong><br>PCA和SVD一般不用，大多数时候不适用于逻辑回归。逻辑回归是由线性回归演变而来，线性回归的一个核心目的是通过求解参数来探究特征X与标签y之间的关系，而逻辑回归也传承了这个性质，我们常常希望通过逻辑回归的结果，来判断什么样的特征与分类结果相关，因此我们希望保留特征的原貌。PCA和SVD的降维结果是不可解释的，因此一旦降维后，我们就无法解释特征和标签之间的关系了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"># 构造列标签名字</span><br><span class="line">column = [&apos;Sample code number&apos;,&apos;Clump Thickness&apos;, &apos;Uniformity of Cell Size&apos;,&apos;Uniformity of Cell Shape&apos;,&apos;Marginal Adhesion&apos;, &apos;Single Epithelial Cell Size&apos;,&apos;Bare Nuclei&apos;,&apos;Bland Chromatin&apos;,&apos;Normal Nucleoli&apos;,&apos;Mitoses&apos;,&apos;Class&apos;]</span><br><span class="line"># 读取数据</span><br><span class="line">data = pd.read_csv(&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&quot;, names=column)</span><br><span class="line"># print(data.head())</span><br></pre></td></tr></table></figure><p><strong>5.3、数据缺失处理，标准化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 缺失值进行处理</span><br><span class="line">data = data.replace(to_replace=&apos;?&apos;, value=np.nan)</span><br><span class="line">data = data.dropna()</span><br><span class="line"># 进行数据的分割</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(data[column[1:10]], data[column[10]], test_size=0.25)</span><br><span class="line"># 进行标准化处理</span><br><span class="line">std = StandardScaler()</span><br><span class="line">x_train = std.fit_transform(x_train)</span><br><span class="line">x_test = std.transform(x_test)</span><br></pre></td></tr></table></figure><p><strong>5.4、估计器流程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 逻辑回归预测</span><br><span class="line">lg = LogisticRegression(C=1.0)</span><br><span class="line">lg.fit(x_train, y_train)</span><br><span class="line">print(lg.coef_)</span><br><span class="line">y_predict = lg.predict(x_test)</span><br><span class="line">print(&quot;准确率：&quot;, lg.score(x_test, y_test))</span><br><span class="line">print(&quot;召回率：&quot;, classification_report(y_test, y_predict, labels=[2, 4], target_names=[&quot;良性&quot;, &quot;恶性&quot;]))</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7289495-38f75f82b94421de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p><strong>应用：</strong><br>广告点击率预测、电商购物搭配推荐、股价预测、产品销量预测</p><p><strong>优点：</strong></p><ul><li>线性回归的数据要求：正态分布，消除多重共线性，现实数据无法满足；逻辑回归不需要对数据进行处理</li><li>对线性关系的拟合效果好</li><li>逻辑回归计算速度快</li><li>返回的分类结果不是固定的0和1，而是以小数形式呈现的类概率数字</li><li>抗噪音能力强</li></ul><p><strong>缺点：</strong>当特征空间很大时，逻辑回归的性能不是很好<br>（看硬件能力）</p></div><footer><div class="categories"><a href="/categories/machinelearning/">机器学习</a></div><div class="tags"><a href="/tags/content/">content</a>, <a href="/tags/machine-learning/">machine learning</a></div><div class="addthis addthis_toolbox addthis_default_style"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a> <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a> <a class="addthis_counter addthis_pill_style"></a></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script><div class="clearfix"></div></footer></div></article><section id="comment"><h1 class="title">留言</h1><div id="fb-root"></div><script>!function(e,t,n){var a,c=e.getElementsByTagName(t)[0];e.getElementById(n)||((a=e.createElement(t)).id=n,a.src="//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345",c.parentNode.insertBefore(a,c))}(document,"script","facebook-jssdk")</script><div class="fb-comments" data-href="http://www.wangpengcufe.com/machinelearning/pythonml-pythonml6/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div></section></div></div><aside id="sidebar" class="alignright"><script language="javascript">function search(e){return e.method="get",e.action="http://www.baidu.com/baidu",document.search_form.word.value=document.search_form.word.value,!0}</script><div class="search"><form name="search_form" target="_blank" onsubmit="search(this)"><input type="search" name="word" results="0" placeholder="百度站内搜索" onblur='this.value=""'></form></div><div class="widget tag"><h3 class="title">分类</h3><ul class="entry"><li><a href="/categories/read/">read</a><small>69</small></li><li><a href="/categories/tools/">工具</a><small>2</small></li><li><a href="/categories/machinelearning/">机器学习</a><small>24</small></li><li><a href="/categories/navigate/">菜单导航</a><small>1</small></li><li><a href="/categories/datadownload/">资料下载</a><small>1</small></li></ul></div><div class="widget tag"><h3 class="title">标签</h3><ul class="entry"><li><a href="/tags/content/">content</a><small>94</small></li><li><a href="/tags/library/">library</a><small>1</small></li><li><a href="/tags/machine-learning/">machine learning</a><small>24</small></li><li><a href="/tags/navigate/">navigate</a><small>1</small></li><li><a href="/tags/tools/">tools</a><small>2</small></li></ul></div><div class="widget tag"><h3 class="title">友情链接</h3><ul class="entry"><li><a href="http://blog.didispace.com" title="程序员DD">程序员DD</a></li><li><a href="https://mangoroom.cn" title="芒果的个人博客">芒果的个人博客</a></li><li><a href="http://www.baimin.com" target="_blank">百鸣网站百科</a></li><li><a href="http://blog.sina.com.cn/u/2435344920" target="_blank">默默读书</a></li><li><a href="https://www.jianshu.com/u/510007ddad06" target="_blank">王小鹏的随笔（简书）</a></li><li><a href="https://me.csdn.net/weixin_42438712" target="_blank">机器学习（csdn博客）</a></li><li><a href="https://zhuanlan.zhihu.com/c_1182309165824901120" target="_blank">机器学习（知乎）</a></li><li><a href="http://meixiaohan.com/" target="_blank">小寒大人的blog</a></li><li><a href="https://baippt.com/" target="_blank">ppt模板免费下载</a></li><li><a href="http://www.youneedcn.com/" target="_blank">你要的资源</a></li></ul></div></aside><div class="clearfix"></div></div><footer id="footer" class="inner"><div class="alignleft">&copy; 2020 王小鹏 京ICP备19037345号-1</div><div class="clearfix"></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></footer><script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">jQuery(".fancybox").fancybox()</script></body></html>