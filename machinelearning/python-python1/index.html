<!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta name="baidu-site-verification" content="kZmc8XTvrB"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?458cfc1440d057b6b8799400c6b2e2bf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta charset="utf-8"><title>案例（一） 利用RFM模型做用户价值分析 | 机器学习 and 数据科学</title><meta name="author" content="王小鹏  京ICP备19037345号-1"><meta name="keywords" content="RMF模型,用户价值分析 PDF电子书下载,电子书，PDF下载"><meta name="description" content="PDF电子书下载,电子书，PDF下载"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="案例（一） 利用RFM模型做用户价值分析"><meta property="og:site_name" content="机器学习 and 数据科学"><meta property="og:image" content><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="机器学习 and 数据科学" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body><header id="header" class="inner"><div class="alignleft"><h1><a href="/">机器学习 and 数据科学</a></h1><h2><a href="/">明天幸福今天修</a></h2></div><nav id="main-nav" class="alignright"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div id="content" class="inner"><div id="main-col" class="alignleft"><div id="wrapper"><article id="post-python-python1" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="post-content"><header><div class="icon"></div><time class="dt-published" datetime="2019-11-25T15:28:56.000Z"><a href="/machinelearning/python-python1/">2019-11-25</a><span id="busuanzi_container_page_pv"> &nbsp;&nbsp;&nbsp;&nbsp;阅读 <span id="busuanzi_value_page_pv"></span></span></time><h1 class="p-name title" itemprop="headline name">案例（一） 利用RFM模型做用户价值分析</h1></header><div class="e-content entry" itemprop="articleBody"><p><img src="http://wangpengcufe.com/python1-1.png" alt="RFM模型"></p><h1 id="一、案例背景"><a href="#一、案例背景" class="headerlink" title="一、案例背景"></a><strong>一、案例背景</strong></h1><p>在产品迭代过程中，通常需要根据用户的属性进行归类，也就是通过分析数据，对用户进行归类，以便于在推送及转化过程中获得更大的收益。</p><p>本案例是基于某互联网公司的实际用户购票数据为研究对象，对用户购票的时间，购买的金额进行了采集，每个用户用手机号来区别唯一性。数据分析人员根据用户购买的时间和金额，通过建立RFM模型，来计算出用户最近最近一次购买的打分，用户购买频率的打分，用户购买金额的打分，然后根据三个分数进行一个加权打分，和综合打分。业务人员可以根据用户的打分情况，对不同的用户进行个性化营销和精准营销，例如给不同的用户推送定制的营销短信，不同优惠额度的打折券等等。</p><p>通过RFM方法，可以根据用户的属性数据分析，对用户进行了归类。在推送、转化等很多过程中，可以更加精准化，不至于出现用户反感的情景，更重要的是，对产品转化等商业价值也有很大的帮助。</p><h1 id="二、RFM概念"><a href="#二、RFM概念" class="headerlink" title="二、RFM概念"></a><strong>二、RFM概念</strong></h1><p>RFM模型是衡量客户价值和客户创利能力的重要工具和手段。在众多的客户关系管理(CRM)的分析模式中，RFM模型是被广泛提到的。该机械模型通过一个客户的近期购买行为、购买的总体频率以及花了多少钱3项指标来描述该客户的价值状况。</p><p><strong>RFM分析</strong> 就是根据客户活跃程度和交易金额的贡献，进行客户价值细分的一种方法。其中：</p><p><strong>R（Recency）</strong>：客户最近一次交易时间的间隔。R值越大，表示客户交易发生的日期越久，反之则表示客户交易发生的日期越近。</p><p><strong>F（Frequency）</strong>：客户在最近一段时间内交易的次数。F值越大，表示客户交易越频繁，反之则表示客户交易不够活跃。</p><p><strong>M（Monetary）</strong>：客户在最近一段时间内交易的金额。M值越大，表示客户价值越高，反之则表示客户价值越低。</p><p><img src="http://wangpengcufe.com/python1-2.png" alt="客户价值"></p><p><strong>R打分：</strong>基于最近一次交易日期计算的得分，距离当前日期越近，得分越高。例如5分制。</p><p><strong>F打分：</strong>基于交易频率计算的得分，交易频率越高，得分越高。如5分制。</p><p><strong>M打分：</strong>基于交易金额计算的得分，交易金额越高，得分越高。如5分制。</p><p><strong>RFM总分值</strong>：RFM=Rx100+Fx10+Mx1</p><p><strong>RFM分析的主要作用：</strong></p><ul><li><p>识别优质客户。可以指定个性化的沟通和营销服务，为更多的营销决策提供有力支持。</p></li><li><p>能够衡量客户价值和客户利润创收能力。</p></li></ul><h1 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a><strong>三、代码实现</strong></h1><h3 id="3-1、引包"><a href="#3-1、引包" class="headerlink" title="3.1、引包"></a><strong>3.1、引包</strong></h3><p>首先我们引入需要用的包，数据分析常用的numpy包，pandas包，等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import mysql.connector</span><br></pre></td></tr></table></figure><h3 id="3-2、读取数据"><a href="#3-2、读取数据" class="headerlink" title="3.2、读取数据"></a><strong>3.2、读取数据</strong></h3><p>接下来我们开始用pd.read_csv方法读取用户的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">print(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,time.localtime(time.time()))+&apos;：读取数据...&apos;)</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &apos;host&apos; : &apos;127.0.0.1&apos;,</span><br><span class="line">    &apos;user&apos; : &apos;root&apos;,</span><br><span class="line">    &apos;password&apos; : &apos;test123&apos;,</span><br><span class="line">    &apos;port&apos; : 3306,</span><br><span class="line">    &apos;database&apos; : &apos;user&apos;,</span><br><span class="line">    &apos;charset&apos; : &apos;gb2312&apos;</span><br><span class="line">&#125;</span><br><span class="line">cnn = mysql.connector.connect(**config) # 建立MySQL连接</span><br><span class="line">cursor = cnn.cursor() # 获得游标</span><br><span class="line">sql = &quot;SELECT  phoneNo AS PHONENO,create_date AS ORDERDATE,order_no AS ORDERNO,ROUND(pay_amount/100,2) AS PAYAMOUNT &quot; \</span><br><span class="line">      &quot;FROM user.`event_record_order`&quot; # SQL语句</span><br><span class="line">raw_data = pd.read_sql(sql,cnn,index_col=&apos;PHONENO&apos;)</span><br><span class="line">cursor.close() # 关闭游标</span><br><span class="line">cnn.close() # 关闭连接</span><br><span class="line">print(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,time.localtime(time.time()))+&apos;：读取数据完毕！&apos;)</span><br><span class="line">print(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,time.localtime(time.time()))+&apos;：开始建立RFM模型...&apos;)</span><br></pre></td></tr></table></figure><p>介绍一下config 里的参数信息：host是数据库的ip信息，本案例用的是本地数据库，实际部署生产服务器时，改成生产的ip地址即可。user 是数据库的用户名，password是密码，port是数据库的端口号，database是连接的数据库名 （schema），charset是字符集编码。</p><p>购票时间（ORDERDATE)，订单号（ORDERID）是object类型，订单金额（AMOUNTINFO）是浮点类型。index_col指定了数据中用户的唯一性用 USERID来表示。</p><p>time.strftime(‘%Y-%m-%d %H:%M:%S’,time.localtime(time.time())打印了当前的系统时间，用来记录日志信息。</p><h3 id="3-3、数据审查"><a href="#3-3、数据审查" class="headerlink" title="3.3、数据审查"></a><strong>3.3、数据审查</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Data Overview :&apos;)</span><br><span class="line">print(raw_data.head(4)) #打印原始数据前4条</span><br><span class="line">print(&apos;-&apos; * 30)</span><br><span class="line">print(&apos;Data DESC:&apos;)</span><br><span class="line">print(raw_data.describe())  #打印原始数据基本描述性信息</span><br></pre></td></tr></table></figure><p>我们用raw_data.head(n)来指定取出数据的前几条，’-‘*30是用来输出打印分隔线，下文再出现时不再重复解释，用raw_data.describe()来获得数据的基本描述性信息。输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Data Overview:</span><br><span class="line">                      ORDERDATE               ORDERNO  PAYAMOUNT</span><br><span class="line">PHONENO                                                         </span><br><span class="line">135****0930 2019-10-02 13:37:36  01201910021336227979        7.0</span><br><span class="line">183****1153 2019-09-30 06:22:29  0120190930062149F9AF        4.5</span><br><span class="line">150****6073 2019-10-30 18:21:45  01201910301821065CFD        2.0</span><br><span class="line">173****7295 2019-10-21 15:13:23  01201910211512498153        7.0</span><br><span class="line">------------------------------</span><br><span class="line">Data DESC:</span><br><span class="line">          PAYAMOUNT</span><br><span class="line">count  96323.000000</span><br><span class="line">mean       4.212409</span><br><span class="line">std        3.049499</span><br><span class="line">min        0.000000</span><br><span class="line">25%        2.600000</span><br><span class="line">50%        3.600000</span><br><span class="line">75%        5.000000</span><br><span class="line">max       80.000000</span><br></pre></td></tr></table></figure><p>我们看到结果中的 count表示总共的记录条数，mean表示了均值，std表示标准差，min表示最小值，25%表示下四分位，也叫第一四分位，50%表示中位值，也叫第二四分位，75%表示上四分位，也叫第三四分位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">na_cols = raw_data.isnull().any(axis=0) #查看每一列是否具有缺失值</span><br><span class="line">print(&apos;NA Cols:&apos;)</span><br><span class="line">print(na_cols)</span><br><span class="line">print(&apos;-&apos; * 30)</span><br><span class="line">na_lines = raw_data.isnull().any(axis=1) #查看每一行是否具有缺失值</span><br><span class="line">print(&apos;NA Records:&apos;)</span><br><span class="line">print(&apos;Total number of NA lines is :&#123;0&#125;&apos;.format(na_lines.sum()))  #查看具有缺失值的行总记录数</span><br><span class="line">print(raw_data[na_lines])  #只查看具有缺失值的行信息</span><br></pre></td></tr></table></figure><p>我们用raw_data.isnull()来判断是否有缺失值，其中参数axis=0表示的是列，axis=1表示的是行，用:{0}’.format()的方式在字符串中传入参数。输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NA Cols:</span><br><span class="line">ORDERDATE    False</span><br><span class="line">ORDERNO      False</span><br><span class="line">PAYAMOUNT    False</span><br><span class="line">dtype: bool</span><br><span class="line">------------------------------</span><br><span class="line">NA Records:</span><br><span class="line">Total number of NA lines is :0</span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: [ORDERDATE, ORDERNO, PAYAMOUNT]</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure><p>通过结果可以看到，实际的交易用户数据还是比较完整的，没有缺失数据的情况，可能这批数据被技术人员采集过来已经处理过了，不讨论了。如果数据有缺失的情况怎么办？那就要对缺失的数据进行一个预处理。</p><h3 id="3-4、数据预处理"><a href="#3-4、数据预处理" class="headerlink" title="3.4、数据预处理"></a><strong>3.4、数据预处理</strong></h3><p>数据预处理，包括数据异常，格式转换，单位转化（如果有单位不统一的情况）等。</p><p>我们先来看<strong>异常值处理：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sales_data = raw_data.dropna() #丢弃带有缺失值的行记录</span><br><span class="line">sales_data = sales_data[sales_data[&apos;PAYAMOUNT&apos;] &gt; 1]</span><br></pre></td></tr></table></figure><p>这里，我用代码去除了小于1元的订单，正常出行连1块钱都不用，那应该是测试数据了，现在谁出门做个公交还不得1元起步。对于用户有缺失值的记录进行了丢弃，当然也可以用其他的方法，例如平均值补全法。</p><p>然后看<strong>日期格式转换：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sales_data[&apos;ORDERDATE&apos;] = pd.to_datetime(sales_data[&apos;ORDERDATE&apos;])</span><br><span class="line">print(&apos;Raw Dtype:&apos;)</span><br><span class="line">print(sales_data.dtypes)</span><br></pre></td></tr></table></figure><p>用pd.to_datetime()方法对用户的订单日期进行了格式化转换。输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Raw Dtype:</span><br><span class="line">ORDERDATE    datetime64[ns]</span><br><span class="line">ORDERNO              object</span><br><span class="line">PAYAMOUNT           float64</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p>最后看<strong>数据转换：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recency_value = sales_data[&apos;ORDERDATE&apos;].groupby(sales_data.index).max()  #计算原始最近一次购买时间</span><br><span class="line">frequency_value = sales_data[&apos;ORDERDATE&apos;].groupby(sales_data.index).count()    #计算原始订单数</span><br><span class="line">monetray_value = sales_data[&apos;PAYAMOUNT&apos;].groupby(sales_data.index).sum()  #计算原始订单总金额</span><br></pre></td></tr></table></figure><p>这里根据订单日期的聚合运算得到了用户的最近一次购买时间，用户总的购买数，和购买金额，max()得到了购买时间，count()得到了购买数量，sum()得到了购买金额。</p><h3 id="3-5、计算RFM得分"><a href="#3-5、计算RFM得分" class="headerlink" title="3.5、计算RFM得分"></a><strong>3.5、计算RFM得分</strong></h3><p>得到了最近的购买时间，购买数，和购买金额，下面就可以开始计算RFM得分了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deadline_date = pd.datetime(2019,11,15)</span><br><span class="line">r_interval = (deadline_date - recency_value).dt.days</span><br><span class="line">r_score = pd.cut(r_interval,5,labels=[5,4,3,2,1])</span><br><span class="line">f_score = pd.cut(frequency_value,5,labels=[1,2,3,4,5])</span><br><span class="line">m_score = pd.cut(monetray_value,5,labels=[1,2,3,4,5])</span><br></pre></td></tr></table></figure><p>我们又把客户分成五等分，这个五等分分析相当于是一个“忠诚度的阶梯”(loyalty ladder)，如购买一次的客户为新客户，购买两次的客户为潜力客户，购买三次的客户为老客户，购买四次的客户为成熟客户，购买五次及以上则为忠实客户。其诀窍在于让消费者一直顺着阶梯往上爬，把销售想象成是要将两次购买的顾客往上推成三次购买的顾客，把一次购买者变成两次的。</p><p>我们用deadline_date来表示分析的截止日期，那么统计用户的时间范围就是从数据中最早开始的购买时间到deadline_date。</p><p>用pandas.series.dt.days可以对操作后的datatime直接进行取数。pandas.cut用来把一组数据分割成离散的区间。</p><p>简单介绍一下pandas.cut的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.cut(x, bins, right=True, labels=None, retbins=False, precision=3, include_lowest=False, duplicates=&apos;raise&apos;)</span><br></pre></td></tr></table></figure><ul><li><strong>x</strong>：被切分的类数组（array-like）数据，必须是1维的（不能用DataFrame）；</li><li><strong>bins</strong>：bins是被切割后的区间（或者叫“桶”、“箱”、“面元”），有3中形式：一个int型的标量、标量序列（数组）或者pandas.IntervalIndex 。<ul><li><strong>一个int型的标量</strong>，当bins为一个int型的标量时，代表将x平分成bins份。x的范围在每侧扩展0.1%，以包括x的最大值和最小值。</li><li>标量序列，标量序列定义了被分割后每一个bin的区间边缘，此时x没有扩展。</li><li>pandas.IntervalIndex，定义要使用的精确区间。</li></ul></li><li>right：bool型参数，默认为True，表示是否包含区间右部。比如如果bins=[1,2,3]，right=True，则区间为(1,2]，(2,3]；right=False，则区间为(1,2),(2,3)。</li><li><strong>labels</strong>：给分割后的bins打标签，比如把年龄x分割成年龄段bins后，可以给年龄段打上诸如青年、中年的标签。labels的长度必须和划分后的区间长度相等，比如bins=[1,2,3]，划分后有2个区间(1,2]，(2,3]，则labels的长度必须为2。如果指定labels=False，则返回x中的数据在第几个bin中（从0开始）。</li><li>retbins：bool型的参数，表示是否将分割后的bins返回，当bins为一个int型的标量时比较有用，这样可以得到划分后的区间，默认为False。</li><li>precision：保留区间小数点的位数，默认为3.</li><li>include_lowest：bool型的参数，表示区间的左边是开还是闭的，默认为false，也就是不包含区间左部（闭）。</li><li>duplicates：是否允许重复区间。有两种选择：raise：不允许，drop：允许。</li></ul><p>重点理解我标粗的几个参数，其他参数有需要用到时查阅。</p><p><strong>RFM数据合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rfm_list = [r_score,f_score,m_score]  #将r、f、m三个维度组成列表</span><br><span class="line">rfm_cols = [&apos;r_score&apos;,&apos;f_score&apos;,&apos;m_score&apos;] #设置r、f、m 三个维度列名</span><br><span class="line">rfm_pd = pd.DataFrame(np.array(rfm_list).transpose(),dtype=np.int32,columns=rfm_cols,index=frequency_value.index) #建立r、f、m数据框</span><br></pre></td></tr></table></figure><p>我们把RFM的数据进行了合并，首先是将r、f、m三个维度组成一个列表，然后取了三个列名，把数据，列名组装成一个数据框DataFrame.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;RFM Score Overview:&apos;)</span><br><span class="line">print(rfm_pd.head(4))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RFM Score Overview:</span><br><span class="line">             r_score  f_score  m_score</span><br><span class="line">PHONENO                               </span><br><span class="line">13001055088        4        1        1</span><br><span class="line">13001061903        4        1        1</span><br><span class="line">13001066446        5        1        1</span><br><span class="line">13001123218        4        1        1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rfm_pd[&apos;rfm_wscore&apos;] = rfm_pd[&apos;r_score&apos;] * 0.6 + rfm_pd[&apos;f_score&apos;] * 0.3 + rfm_pd[&apos;m_score&apos;] * 0.1</span><br><span class="line">rfm_pd_tmp = rfm_pd.copy()</span><br><span class="line">rfm_pd_tmp[&apos;r_score&apos;] = rfm_pd_tmp[&apos;r_score&apos;].astype(&apos;str&apos;)</span><br><span class="line">rfm_pd_tmp[&apos;f_score&apos;] = rfm_pd_tmp[&apos;f_score&apos;].astype(&apos;str&apos;)</span><br><span class="line">rfm_pd_tmp[&apos;m_score&apos;] = rfm_pd_tmp[&apos;m_score&apos;].astype(&apos;str&apos;)</span><br><span class="line">rfm_pd[&apos;rfm_comb&apos;] = rfm_pd_tmp[&apos;r_score&apos;].str.cat(rfm_pd_tmp[&apos;f_score&apos;]).str.cat(rfm_pd_tmp[&apos;m_score&apos;])</span><br></pre></td></tr></table></figure><p>理论上，上一次消费时间越近的顾客应该是比较好的顾客，对提供即时的商品或是服务也最有可能会有反应。营销人员若想业绩有所成长，只能靠偷取竞争对手的市场占有率，而如果要密切地注意消费者的购买行为，那么最近的一次消费就是营销人员第一个要利用的工具。历史显示，如果我们能让消费者购买，他们就会持续购买。这也就是为什么，0至3个月的顾客收到营销人员的沟通信息多于3至6个月的顾客。</p><p>这里，对RFM进行了加权打分，R占60%，F占30%，M占10%，当然也可以根据业务的实际情况进行相应的权重调整。综合打分是根据RFM=R<em>100+F</em>10+M*1。</p><h3 id="3-6、保存结果"><a href="#3-6、保存结果" class="headerlink" title="3.6、保存结果"></a><strong>3.6、保存结果</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Final RFM Score Overview:&apos;)</span><br><span class="line">print(rfm_pd.head(4))</span><br><span class="line">print(&apos;-&apos;*30)</span><br><span class="line">print(&apos;Final RFM Score DESC:&apos;)</span><br><span class="line">print(rfm_pd.describe())</span><br><span class="line"></span><br><span class="line">rfm_pd.to_csv(&apos;sales_rfm_score.csv&apos;)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Final RFM Score Overview:</span><br><span class="line">             r_score  f_score  m_score  rfm_wscore rfm_comb</span><br><span class="line">PHONENO                                                    </span><br><span class="line">13001055088        4        1        1         2.8      411</span><br><span class="line">13001061903        4        1        1         2.8      411</span><br><span class="line">13001066446        5        1        1         3.4      511</span><br><span class="line">13001123218        4        1        1         2.8      411</span><br><span class="line">------------------------------</span><br><span class="line">Final RFM Score DESC:</span><br><span class="line">            r_score       f_score       m_score    rfm_wscore</span><br><span class="line">count  53064.000000  53064.000000  53064.000000  53064.000000</span><br><span class="line">mean       3.732172      1.006407      1.002148      2.641441</span><br><span class="line">std        0.944452      0.113022      0.055212      0.570417</span><br><span class="line">min        1.000000      1.000000      1.000000      1.000000</span><br><span class="line">25%        3.000000      1.000000      1.000000      2.200000</span><br><span class="line">50%        4.000000      1.000000      1.000000      2.800000</span><br><span class="line">75%        5.000000      1.000000      1.000000      3.400000</span><br></pre></td></tr></table></figure><h3 id="3-7、写入数据库"><a href="#3-7、写入数据库" class="headerlink" title="3.7、写入数据库"></a><strong>3.7、写入数据库</strong></h3><p><strong>建立数据库连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">table_name = &apos;sale_rfm_score&apos;</span><br><span class="line">#数据框基本信息</span><br><span class="line">config = &#123;</span><br><span class="line">    &apos;host&apos; : &apos;172.0.0.1&apos;,</span><br><span class="line">    &apos;user&apos; : &apos;root&apos;,</span><br><span class="line">    &apos;password&apos; : &apos;test123&apos;,</span><br><span class="line">    &apos;port&apos; : 3306,</span><br><span class="line">    &apos;database&apos; : &apos;skpda&apos;,</span><br><span class="line">    &apos;charset&apos; : &apos;gb2312&apos;</span><br><span class="line">&#125;</span><br><span class="line">con = mysql.connector.connect(**config)</span><br><span class="line">cursor = con.cursor()</span><br><span class="line"></span><br><span class="line">cursor.execute(&quot;show tables&quot;)  #</span><br><span class="line">table_object = cursor.fetchall()  # 通过fetchall方法获得所有数据</span><br><span class="line">table_list = []  # 创建库列表</span><br><span class="line">for t in table_object:  # 循环读出所有库</span><br><span class="line">    table_list.append(t[0])  # 每个每个库追加到列表</span><br><span class="line">if not table_name in table_list:  # 如果目标表没有创建</span><br><span class="line">    cursor.execute(&apos;&apos;&apos;</span><br><span class="line">    CREATE TABLE %s (</span><br><span class="line">    phone_no               VARCHAR(20),</span><br><span class="line">    r_score               int(2),</span><br><span class="line">    f_score              int(2),</span><br><span class="line">    m_score              int(2),</span><br><span class="line">    rfm_wscore              DECIMAL(10,2),</span><br><span class="line">    rfm_comb              VARCHAR(10),</span><br><span class="line">    create_date              VARCHAR(20)</span><br><span class="line">    )ENGINE=InnoDB DEFAULT CHARSET=gb2312</span><br><span class="line">    &apos;&apos;&apos; % table_name)  # 创建新表</span><br><span class="line">print(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,time.localtime(time.time()))+ &apos;：开始清除 table &#123;0&#125;的历史数据...&apos;.format(table_name)) # 输出开始清历史数据的提示信息</span><br><span class="line">delete_sql = &apos;truncate table &#123;0&#125;&apos;.format(table_name)</span><br><span class="line">cursor.execute(delete_sql)</span><br><span class="line">print(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,time.localtime(time.time()))+ &apos;：清除 table &#123;0&#125;的历史数据完毕！&apos;.format(table_name)) # 输出清除历史数据完毕的提示信息</span><br></pre></td></tr></table></figure><p>连接的参数不再介绍，上文已经介绍过。通过fetchall方法获得所有数据,读出所有的表，如果没有表则创建。用cursor.execute先执行truncate语句，把表中的信息先清除，然后重新写入数据。</p><p><strong>将数据写入数据库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">phone_no = rfm_pd.index # 索引列</span><br><span class="line">rfm_wscore = rfm_pd[&apos;rfm_wscore&apos;]  #RFM 加权得分列</span><br><span class="line">rfm_comb = rfm_pd[&apos;rfm_comb&apos;]  #RFM组合得分列</span><br><span class="line">timestamp = time.strftime(&apos;%Y-%m-%d&apos;,time.localtime(time.time())) # 写库日期</span><br><span class="line">print(&apos;开始写入数据库表 &#123;0&#125;&apos;.format(table_name)) # 输出开始写库的提示信息</span><br><span class="line">for i in range(rfm_pd.shape[0]):</span><br><span class="line">    insert_sql = &quot;INSERT INTO `%s` VALUES (&apos;%s&apos;,%s,%s,%s,%s,%s,&apos;%s&apos;)&quot; % \</span><br><span class="line">                 (table_name, phone_no[i], r_score.iloc[i], f_score.iloc[i], m_score.iloc[i], rfm_wscore.iloc[i],</span><br><span class="line">                  rfm_comb.iloc[i], timestamp)  # 写库SQL依据</span><br><span class="line">    cursor.execute(insert_sql)</span><br><span class="line">    con.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">con.close()</span><br><span class="line">print(&apos;写入数据库结束，总记录条数为: %d&apos; %(i+1))</span><br></pre></td></tr></table></figure><p>先从数据集合 rfm_pd （rfm_pd 是一个DataFrame）中获取到rfm的每个字段， ’….{0}’.format(table_name)表示的是在字符串中拼接参数，{0}代表一个字符串占位符。</p><h1 id="四、案例结果分析"><a href="#四、案例结果分析" class="headerlink" title="四、案例结果分析"></a><strong>四、案例结果分析</strong></h1><p>根据RFM模型的建立，我们在数据库里生成了数据。</p><p><img src="http://wangpengcufe.com/python1-3.png" alt="数据库表生成"></p><p>然后前段工程师根据数据库里的数据得到了用户RFM的价值打分页面，如图（后台展示页面）。</p><p>运营人员根据页面的打分情况来衡量客户价值和客户创利能力，了解客户差异。将客户分别按照R、F、M参数分组后，假设某个客户同时属于R5、F4、M3三个组，则可以得到该客户的RFM代码543。同理，我们可以推测，有一些客户刚刚成功交易、且交易频率高、总采购金额大，其RFM代码是555，还有一些客户的RFM代码是554、545……每一个RFM代码都对应着一小组客户，开展市场营销活动的时候可以从中挑选出若干组进行。<br><img src="http://wangpengcufe.com/python1-4.png" alt="后台展示页面"></p><p>用户是根据RFM的打分倒序排列，可以直接找到重点客户的信息，点开手机号，查看客户的详细信息（这一步由前端开发人员实现），针对重点客户展开各种个性化营销。</p><p><img src="http://wangpengcufe.com/python1-5.png" alt="重点客户详细信息"></p><p>RFM三个指标每个维度再细分出5份，这样就能够细分出5x5x5=125类用户，再根据每类用户精准营销……显然125类用户已超出普通人脑的计算范畴了，更别说针对125类用户量体定制营销策略。实际运用上，我们只需要把每个维度做一次两分即可，这样在3个维度上我们依然得到了8组用户。</p><p>这样，就可以得到以下解读（编号次序RFM,1代表高，0代表低）<br>重要价值客户（111）：最近消费时间近、消费频次和消费金额都很高，必须是VIP啊！<br>重要保持客户（011）：最近消费时间较远，但消费频次和金额都很高，说明这是个一段时间没来的忠诚客户，我们需要主动和他保持联系。<br>重要发展客户（101）：最近消费时间较近、消费金额高，但频次不高，忠诚度不高，很有潜力的用户，必须重点发展。<br>重要挽留客户（001）：最近消费时间较远、消费频次不高，但消费金额高的用户，可能是将要流失或者已经要流失的用户，应当基于挽留措施。</p><p><strong>案例结论：</strong></p><ul><li>表现处于一般水平以上的用户的比例太小，低于1%（R、F、M三个维度得分均在3以上的用户数），VIP客户太少。</li><li>会员中99%以上的客户消费状态都不容乐观，主要体现在消费频率低R、消费总金额低M。这可能跟公司的地铁出行的业务有关系，公司的业务分布在全国中小城市，大部分用户都是使用一次的用户。</li><li>低价值客户有262个，占总比例的 0.4%，运营人员可以导出下载这批用户。</li></ul><p>下一节，讲一下在linux服务器上部署python应用。</p></div><footer><div class="categories"><a href="/categories/machinelearning/">机器学习</a></div><div class="tags"><a href="/tags/content/">content</a>, <a href="/tags/machine-learning/">machine learning</a></div><div class="addthis addthis_toolbox addthis_default_style"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a> <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a> <a class="addthis_counter addthis_pill_style"></a></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script><div class="clearfix"></div></footer></div></article><section id="comment"><h1 class="title">留言</h1><div id="fb-root"></div><script>!function(e,t,n){var a,c=e.getElementsByTagName(t)[0];e.getElementById(n)||((a=e.createElement(t)).id=n,a.src="//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345",c.parentNode.insertBefore(a,c))}(document,"script","facebook-jssdk")</script><div class="fb-comments" data-href="http://www.wangpengcufe.com/machinelearning/python-python1/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div></section></div></div><aside id="sidebar" class="alignright"><script language="javascript">function search(e){return e.method="get",e.action="http://www.baidu.com/baidu",document.search_form.word.value=document.search_form.word.value,!0}</script><div class="search"><form name="search_form" target="_blank" onsubmit="search(this)"><input type="search" name="word" results="0" placeholder="百度站内搜索" onblur='this.value=""'></form></div><div class="widget tag"><h3 class="title">分类</h3><ul class="entry"><li><a href="/categories/read/">read</a><small>69</small></li><li><a href="/categories/tools/">工具</a><small>7</small></li><li><a href="/categories/machinelearning/">机器学习</a><small>25</small></li><li><a href="/categories/navigate/">菜单导航</a><small>1</small></li><li><a href="/categories/datadownload/">资料下载</a><small>1</small></li></ul></div><div class="widget tag"><h3 class="title">标签</h3><ul class="entry"><li><a href="/tags/content/">content</a><small>100</small></li><li><a href="/tags/library/">library</a><small>1</small></li><li><a href="/tags/machine-learning/">machine learning</a><small>25</small></li><li><a href="/tags/navigate/">navigate</a><small>1</small></li><li><a href="/tags/tools/">tools</a><small>7</small></li></ul></div><div class="widget tag"><h3 class="title">友情链接</h3><ul class="entry"><li><a href="http://blog.didispace.com" title="程序员DD">程序员DD</a></li><li><a href="https://mangoroom.cn" title="芒果的个人博客">芒果的个人博客</a></li><li><a href="http://www.baimin.com" target="_blank">百鸣网站百科</a></li><li><a href="http://blog.sina.com.cn/u/2435344920" target="_blank">默默读书</a></li><li><a href="https://www.jianshu.com/u/510007ddad06" target="_blank">王小鹏的随笔（简书）</a></li><li><a href="https://me.csdn.net/weixin_42438712" target="_blank">机器学习（csdn博客）</a></li><li><a href="https://zhuanlan.zhihu.com/c_1182309165824901120" target="_blank">机器学习（知乎）</a></li><li><a href="http://meixiaohan.com/" target="_blank">小寒大人的blog</a></li><li><a href="https://baippt.com/" target="_blank">ppt模板免费下载</a></li><li><a href="http://www.youneedcn.com/" target="_blank">你要的资源</a></li></ul></div></aside><div class="clearfix"></div></div><footer id="footer" class="inner"><div class="alignleft">&copy; 2020 王小鹏 京ICP备19037345号-1</div><div class="clearfix"></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></footer><script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">jQuery(".fancybox").fancybox()</script></body></html>