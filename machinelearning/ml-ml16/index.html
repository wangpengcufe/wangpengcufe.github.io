<!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta name="baidu-site-verification" content="kZmc8XTvrB"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?458cfc1440d057b6b8799400c6b2e2bf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta charset="utf-8"><title>机器学习（十六） 特征变换-标签和索引的转化 | 机器学习 and 数据科学</title><meta name="author" content="王小鹏  京ICP备19037345号-1"><meta name="keywords" content="机器学习,特征变换,标签和索引的转化 PDF电子书下载,电子书，PDF下载"><meta name="description" content="PDF电子书下载,电子书，PDF下载"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="机器学习（十六） 特征变换-标签和索引的转化"><meta property="og:site_name" content="机器学习 and 数据科学"><meta property="og:image" content><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="机器学习 and 数据科学" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body><header id="header" class="inner"><div class="alignleft"><h1><a href="/">机器学习 and 数据科学</a></h1><h2><a href="/">明天幸福今天修</a></h2></div><nav id="main-nav" class="alignright"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div id="content" class="inner"><div id="main-col" class="alignleft"><div id="wrapper"><article id="post-ml-ml16" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="post-content"><header><div class="icon"></div><time class="dt-published" datetime="2019-11-25T15:28:56.000Z"><a href="/machinelearning/ml-ml16/">2019-11-25</a><span id="busuanzi_container_page_pv"> &nbsp;&nbsp;&nbsp;&nbsp;阅读 <span id="busuanzi_value_page_pv"></span></span></time><h1 class="p-name title" itemprop="headline name">机器学习（十六） 特征变换-标签和索引的转化</h1></header><div class="e-content entry" itemprop="articleBody"><p><img src="http://wangpengcufe.com/ml16.png" alt="卡方选择器"></p><h1 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a><strong>一、原理</strong></h1><p>在机器学习处理过程中,为了方便相关算法的实现,经常需要把标签数据(一般是字符串)转化成整数索引,或是在计算结束后将整数索引还原为相应的标签.<br>Spark ML 包中提供了几个相关的转换器:<br>StringIndexer,IndexToString,OneHotEncoder,VectorIndexer,他们提供了十分方便的特征转换功能,这些转换器都位于org.apache.spark.ml.feature包下。</p><p>值得注意的是,用于特征转换的转换器和其他的机器学习算法一样,也属于Ml Pipeline模型的一部分,可以用来构成机器学习流水线,以StringIndexer为例。</p><p>StringIndexer（字符串-索引变换）将字符串的标签编码成标签索引。标签索引序列的取值范围是[0，numLabels（字符串中所有出现的单词去掉重复的词后的总和）]，按照标签出现频率排序，出现最多的标签索引为0。如果输入是数值型，我们先将数值映射到字符串，再对字符串进行索引化。如果下游的pipeline（例如：Estimator或者Transformer）需要用到索引化后的标签序列，则需要将这个pipeline的输入列名字指定为索引化序列的名字。大部分情况下，通过setInputCol设置输入的列名。</p><p>下面来具体介绍StringIndexer、IndexToString、OneHotEncoder、VectorIndexer。</p><h1 id="二、StringIndexer（字符串-索引变换）"><a href="#二、StringIndexer（字符串-索引变换）" class="headerlink" title="二、StringIndexer（字符串-索引变换）"></a><strong>二、StringIndexer（字符串-索引变换）</strong></h1><h3 id="2-1、原理"><a href="#2-1、原理" class="headerlink" title="2.1、原理"></a><strong>2.1、原理</strong></h3><p>StringIndexer将标签的字符串列编码为标签索引的列。 索引位于[0，numLabels）中，并支持四个排序选项：“frequencyDesc”：按标签频率的降序（最频繁的标签分配为0），“frequencyAsc”：按标签频率的升序（最不频繁的标签分配为0） ，“alphabetDesc”：降序字母顺序和“alphabetAsc”：升序字母顺序（默认=“frequencyDesc”）。 如果用户选择保留，则看不见的标签将放置在索引numLabels处。 如果输入列为数字，则将其强制转换为字符串并为字符串值编制索引。 当下游管道组件（例如Estimator或Transformer）使用此字符串索引标签时，必须将组件的输入列设置为此字符串索引列名称。 在许多情况下，可以使用setInputCol设置输入列。</p><h3 id="2-2、代码实现"><a href="#2-2、代码实现" class="headerlink" title="2.2、代码实现"></a><strong>2.2、代码实现</strong></h3><p>首先引入需要用的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import org.apache.spark.ml.feature.IndexToString;</span><br><span class="line">import org.apache.spark.ml.feature.OneHotEncoderEstimator;</span><br><span class="line">import org.apache.spark.ml.feature.StringIndexer;</span><br><span class="line">import org.apache.spark.ml.feature.StringIndexerModel;</span><br><span class="line">import org.apache.spark.ml.feature.VectorIndexer;</span><br><span class="line">import org.apache.spark.ml.feature.VectorIndexerModel;</span><br><span class="line">import org.apache.spark.ml.linalg.VectorUDT;</span><br><span class="line">import org.apache.spark.ml.linalg.Vectors;</span><br><span class="line">import org.apache.spark.sql.Dataset;</span><br><span class="line">import org.apache.spark.sql.Row;</span><br><span class="line">import org.apache.spark.sql.RowFactory;</span><br><span class="line">import org.apache.spark.sql.SparkSession;</span><br><span class="line">import org.apache.spark.sql.types.DataTypes;</span><br><span class="line">import org.apache.spark.sql.types.Metadata;</span><br><span class="line">import org.apache.spark.sql.types.StructField;</span><br><span class="line">import org.apache.spark.sql.types.StructType;</span><br><span class="line">import scala.collection.immutable.Set;</span><br></pre></td></tr></table></figure><p>获取spark:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparkSession spark = SparkSession.builder().appName(&quot;StringIndexerTest&quot;).master(&quot;local&quot;).getOrCreate();</span><br></pre></td></tr></table></figure><p>构造一些简单数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Row&gt; rowRDD = Arrays.asList(RowFactory.create(0,&quot;a&quot;),</span><br><span class="line">                        RowFactory.create(1,&quot;b&quot;),</span><br><span class="line">                        RowFactory.create(2,&quot;c&quot;),</span><br><span class="line">                        RowFactory.create(3,&quot;a&quot;),</span><br><span class="line">                        RowFactory.create(4,&quot;a&quot;),</span><br><span class="line">                        RowFactory.create(5,&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">StructType schema = new StructType(new StructField[] &#123;</span><br><span class="line">        new StructField(&quot;id&quot;,DataTypes.IntegerType,false,Metadata.empty()),</span><br><span class="line">        new StructField(&quot;category&quot;,DataTypes.StringType,false,Metadata.empty())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Dataset&lt;Row&gt; df = spark.createDataFrame(rowRDD, schema);</span><br><span class="line">df.show(false);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+--------+</span><br><span class="line">|id |category|</span><br><span class="line">+---+--------+</span><br><span class="line">|0  |a       |</span><br><span class="line">|1  |b       |</span><br><span class="line">|2  |c       |</span><br><span class="line">|3  |a       |</span><br><span class="line">|4  |a       |</span><br><span class="line">|5  |c       |</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure><p>然后构建StringIndexer模型，我们创建一个StringIndexer对象，设定输入输出列名，其余参数采用默认值，并对这个DataFrame进行训练，产生StringIndexerModel对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringIndexer indexer = new StringIndexer().setInputCol(&quot;category&quot;).setOutputCol(&quot;categoryIndex&quot;);</span><br><span class="line">StringIndexerModel model = indexer.fit(df);</span><br></pre></td></tr></table></figure><p>之后我们即可利用StringIndexerModel对象对DataFrame数据进行转换操作，可以看到，默认情况下，StringIndexerModel依次按照出现频率的高低，把字符标签进行了排序，即出现最多的“a”被编号成0，“c”为1，出现最少的“b”为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dataset&lt;Row&gt; indexed1 = model.transform(df);</span><br><span class="line">indexed1.show(false);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+--------+-------------+</span><br><span class="line">|id |category|categoryIndex|</span><br><span class="line">+---+--------+-------------+</span><br><span class="line">|0  |a       |0.0          |</span><br><span class="line">|1  |b       |2.0          |</span><br><span class="line">|2  |c       |1.0          |</span><br><span class="line">|3  |a       |0.0          |</span><br><span class="line">|4  |a       |0.0          |</span><br><span class="line">|5  |c       |1.0          |</span><br><span class="line">+---+--------+-------------+</span><br></pre></td></tr></table></figure><p>如果我们使用已有的数据构建了一个StringIndexerModel，然后再构建一个新的DataFrame，这个DataFrame中有着模型内未曾出现的标签“d”，用已有的模型去转换这一DataFrame会有什么效果？<br>实际上，如果直接转换的话，Spark会抛出异常，报出“Unseen label: d”的错误。<br>为了处理这种情况，在模型训练后，可以通过设置setHandleInvalid(“skip”)来忽略掉那些未出现的标签，这样，带有未出现标签的行将直接被过滤掉，所下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Row&gt; rowRDD2 = Arrays.asList(RowFactory.create(0,&quot;a&quot;),</span><br><span class="line">        RowFactory.create(1,&quot;b&quot;),</span><br><span class="line">        RowFactory.create(2,&quot;c&quot;),</span><br><span class="line">        RowFactory.create(3,&quot;a&quot;),</span><br><span class="line">        RowFactory.create(4,&quot;a&quot;),</span><br><span class="line">        RowFactory.create(5,&quot;d&quot;));</span><br><span class="line">Dataset&lt;Row&gt; df2 = spark.createDataFrame(rowRDD2, schema);</span><br><span class="line">Dataset&lt;Row&gt; indexed2 = model.transform(df2);</span><br><span class="line">indexed2.show(false);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unseen label: d.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dataset&lt;Row&gt; indexed2 = model.setHandleInvalid(&quot;skip&quot;).transform(df2);</span><br><span class="line">indexed2.show(false);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---+--------+-------------+</span><br><span class="line">|id |category|categoryIndex|</span><br><span class="line">+---+--------+-------------+</span><br><span class="line">|0  |a       |0.0          |</span><br><span class="line">|1  |b       |2.0          |</span><br><span class="line">|2  |c       |1.0          |</span><br><span class="line">|3  |a       |0.0          |</span><br><span class="line">|4  |a       |0.0          |</span><br><span class="line">+---+--------+-------------+</span><br></pre></td></tr></table></figure><h1 id="三、IndexToString（索引-字符串变换）"><a href="#三、IndexToString（索引-字符串变换）" class="headerlink" title="三、IndexToString（索引-字符串变换）"></a><strong>三、IndexToString（索引-字符串变换）</strong></h1><h3 id="3-1、原理"><a href="#3-1、原理" class="headerlink" title="3.1、原理"></a><strong>3.1、原理</strong></h3><p>与StringIndexer对应，IndexToString将索引化标签还原成原始字符串。一个常用的场景是先通过StringIndexer产生索引化标签，然后使用索引化标签进行训练，最后再对预测结果使用IndexToString来获取其原始的标签字符串。</p><h3 id="3-2、代码实现"><a href="#3-2、代码实现" class="headerlink" title="3.2、代码实现"></a><strong>3.2、代码实现</strong></h3><p>首先我们用StringIndexer读取数据集中的“category”列，把字符型标签转化成标签索引，然后输出到“categoryIndex”列上，构建出一个新的DataFrame数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Row&gt; rawData =  Arrays.asList(RowFactory.create(0, &quot;a&quot;),</span><br><span class="line">                        RowFactory.create(1, &quot;b&quot;),</span><br><span class="line">                        RowFactory.create(2, &quot;c&quot;),</span><br><span class="line">                        RowFactory.create(3, &quot;a&quot;),</span><br><span class="line">                        RowFactory.create(4, &quot;a&quot;),</span><br><span class="line">                        RowFactory.create(5, &quot;c&quot;));</span><br><span class="line"></span><br><span class="line">Dataset&lt;Row&gt; df3 = spark.createDataFrame(rawData, schema);</span><br><span class="line">Dataset&lt;Row&gt; indexed3 = indexer.fit(df3).transform(df3);</span><br></pre></td></tr></table></figure><p>然后我们创建IndexToString对象，读取“categoryIndex”上的标签索引，获得原有数据集的字符型标签，然后再输出到“originalCategory”列上。最后，通过输出“originalCategory”列，就可以看到数据集中原有的字符标签了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IndexToString converter = new IndexToString().setInputCol(&quot;categoryIndex&quot;).setOutputCol(&quot;originalCategory&quot;);</span><br><span class="line">Dataset&lt;Row&gt; converted3 = converter.transform(indexed3);</span><br><span class="line">converted3.show(false);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+--------+-------------+----------------+</span><br><span class="line">|id |category|categoryIndex|originalCategory|</span><br><span class="line">+---+--------+-------------+----------------+</span><br><span class="line">|0  |a       |0.0          |a               |</span><br><span class="line">|1  |b       |2.0          |b               |</span><br><span class="line">|2  |c       |1.0          |c               |</span><br><span class="line">|3  |a       |0.0          |a               |</span><br><span class="line">|4  |a       |0.0          |a               |</span><br><span class="line">|5  |c       |1.0          |c               |</span><br><span class="line">+---+--------+-------------+----------------+</span><br></pre></td></tr></table></figure><h1 id="四、OneHotEncoder（独热编码）"><a href="#四、OneHotEncoder（独热编码）" class="headerlink" title="四、OneHotEncoder（独热编码）"></a><strong>四、OneHotEncoder（独热编码）</strong></h1><h3 id="4-1、原理"><a href="#4-1、原理" class="headerlink" title="4.1、原理"></a><strong>4.1、原理</strong></h3><p>独热编码（One-hot encoding）将类别特征映射为二进制向量，其中只有一个有效值（为1，其余为0）。这样在诸如Logistic回归这样需要连续数值值作为特征输入的分类器中也可以使用类别（离散）特征。</p><p>One-Hot编码适合一些期望类别特征为连续特征的算法，比如说逻辑斯蒂回归等。</p><h3 id="4-2、代码实现"><a href="#4-2、代码实现" class="headerlink" title="4.2、代码实现"></a><strong>4.2、代码实现</strong></h3><p>首先创建一个DataFrame，其包含一列类别性特征，需要注意的是，在使用OneHotEncoder进行转换前，DataFrame需要先使用StringIndexer将原始标签数值化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Row&gt; rawData4 = Arrays.asList(RowFactory.create(0.0, 1.0),</span><br><span class="line">          RowFactory.create(1.0, 0.0),</span><br><span class="line">          RowFactory.create(2.0, 1.0),</span><br><span class="line">          RowFactory.create(0.0, 2.0),</span><br><span class="line">          RowFactory.create(0.0, 1.0),</span><br><span class="line">          RowFactory.create(2.0, 0.0));</span><br><span class="line"></span><br><span class="line">StructType schema4 = new StructType(new StructField[] &#123;</span><br><span class="line">        new StructField(&quot;id&quot;,DataTypes.DoubleType,false,Metadata.empty()),</span><br><span class="line">        new StructField(&quot;category&quot;,DataTypes.DoubleType,false,Metadata.empty())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Dataset&lt;Row&gt; df4 = spark.createDataFrame(rawData4, schema4);</span><br></pre></td></tr></table></figure><p>我们创建OneHotEncoder对象对处理后的DataFrame进行编码，可以看见，编码后的二进制特征呈稀疏向量形式，与StringIndexer编码的顺序相同，需注意的是最后一个Category（”b”）被编码为全0向量，若希望”b”也占有一个二进制特征，则可在创建OneHotEncoder时指定setDropLast(false)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OneHotEncoderEstimator encoder = new OneHotEncoderEstimator()</span><br><span class="line">                               .setInputCols(new String[] &#123;&quot;id&quot;,&quot;category&quot;&#125;)</span><br><span class="line">                               .setOutputCols(new String[] &#123;&quot;categoryVec1&quot;,&quot;categoryVec2&quot;&#125;);</span><br><span class="line">Dataset&lt;Row&gt; encoded4 = encoder.fit(df4).transform(df4);</span><br><span class="line">encoded4.show(false);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+--------+-------------+-------------+</span><br><span class="line">|id |category|categoryVec1 |categoryVec2 |</span><br><span class="line">+---+--------+-------------+-------------+</span><br><span class="line">|0.0|1.0     |(2,[0],[1.0])|(2,[1],[1.0])|</span><br><span class="line">|1.0|0.0     |(2,[1],[1.0])|(2,[0],[1.0])|</span><br><span class="line">|2.0|1.0     |(2,[],[])    |(2,[1],[1.0])|</span><br><span class="line">|0.0|2.0     |(2,[0],[1.0])|(2,[],[])    |</span><br><span class="line">|0.0|1.0     |(2,[0],[1.0])|(2,[1],[1.0])|</span><br><span class="line">|2.0|0.0     |(2,[],[])    |(2,[0],[1.0])|</span><br><span class="line">+---+--------+-------------+-------------+</span><br></pre></td></tr></table></figure><h1 id="五、VectorIndexer-向量类型索引化"><a href="#五、VectorIndexer-向量类型索引化" class="headerlink" title="五、VectorIndexer(向量类型索引化)"></a><strong>五、VectorIndexer(向量类型索引化)</strong></h1><h3 id="5-1、原理"><a href="#5-1、原理" class="headerlink" title="5.1、原理"></a><strong>5.1、原理</strong></h3><p>VectorIndexer帮助索引Vector数据集中的分类特征。 它既可以自动确定哪些特征是分类的，又可以将原始值转换为分类索引。 具体来说，它执行以下操作：</p><p>1、设置类型为Vector的输入列和参数maxCategories。<br>2、根据不同值的数量确定应分类的要素，其中最多具有maxCategories的要素被声明为分类。<br>3、为每个分类特征计算从0开始的分类索引。<br>4、为分类特征建立索引，并将原始特征值转换为索引。</p><p>索引分类特征允许诸如决策树和树组合之类的算法适当地处理分类特征，从而提高性能。</p><h3 id="5-2、代码实现"><a href="#5-2、代码实现" class="headerlink" title="5.2、代码实现"></a><strong>5.2、代码实现</strong></h3><p>首先，我们读入一个数据集DataFrame，然后使用VectorIndexer训练出模型，来决定哪些特征需要被作为类别特征，将类别特征转换为索引，这里设置maxCategories为2，即只有种类小于2的特征才被认为是类别型特征，否则被认为是连续型特征：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Row&gt; rawData5 = Arrays.asList(RowFactory.create(Vectors.dense(-1.0, 1.0, 1.0)),</span><br><span class="line">                RowFactory.create(Vectors.dense(-1.0, 3.0, 1.0)),</span><br><span class="line">                RowFactory.create(Vectors.dense(0.0, 5.0, 1.0)));</span><br><span class="line"></span><br><span class="line">StructType schema5 = new StructType(new StructField[] &#123;</span><br><span class="line">        new StructField(&quot;features&quot;,new VectorUDT(),false,Metadata.empty())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Dataset&lt;Row&gt; df5 = spark.createDataFrame(rawData5, schema5);</span><br><span class="line">df5.show(false);</span><br><span class="line">VectorIndexerModel indexModel = new VectorIndexer()</span><br><span class="line">                                .setInputCol(&quot;features&quot;)</span><br><span class="line">                                .setOutputCol(&quot;indexed&quot;)</span><br><span class="line">                                .setMaxCategories(2).fit(df5);</span><br><span class="line">Set&lt;Object&gt; categoricalFeatures = indexModel.categoryMaps().keySet();</span><br><span class="line">System.out.println(categoricalFeatures.mkString(&quot;,&quot;));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dataset&lt;Row&gt; indexed5 = indexModel.transform(df5);</span><br><span class="line">indexed5.show(false);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------+-------------+</span><br><span class="line">|features      |indexed      |</span><br><span class="line">+--------------+-------------+</span><br><span class="line">|[-1.0,1.0,1.0]|[1.0,1.0,0.0]|</span><br><span class="line">|[-1.0,3.0,1.0]|[1.0,3.0,0.0]|</span><br><span class="line">|[0.0,5.0,1.0] |[0.0,5.0,0.0]|</span><br><span class="line">+--------------+-------------+</span><br></pre></td></tr></table></figure></div><footer><div class="categories"><a href="/categories/machinelearning/">机器学习</a></div><div class="tags"><a href="/tags/content/">content</a>, <a href="/tags/machine-learning/">machine learning</a></div><div class="addthis addthis_toolbox addthis_default_style"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a> <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a> <a class="addthis_counter addthis_pill_style"></a></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script><div class="clearfix"></div></footer></div></article><section id="comment"><h1 class="title">留言</h1><div id="fb-root"></div><script>!function(e,t,n){var a,c=e.getElementsByTagName(t)[0];e.getElementById(n)||((a=e.createElement(t)).id=n,a.src="//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345",c.parentNode.insertBefore(a,c))}(document,"script","facebook-jssdk")</script><div class="fb-comments" data-href="http://www.wangpengcufe.com/machinelearning/ml-ml16/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div></section></div></div><aside id="sidebar" class="alignright"><script language="javascript">function search(e){return e.method="get",e.action="http://www.baidu.com/baidu",document.search_form.word.value=document.search_form.word.value,!0}</script><div class="search"><form name="search_form" target="_blank" onsubmit="search(this)"><input type="search" name="word" results="0" placeholder="百度站内搜索" onblur='this.value=""'></form></div><div class="widget tag"><h3 class="title">分类</h3><ul class="entry"><li><a href="/categories/read/">read</a><small>65</small></li><li><a href="/categories/tools/">工具</a><small>3</small></li><li><a href="/categories/machinelearning/">机器学习</a><small>22</small></li><li><a href="/categories/navigate/">菜单导航</a><small>1</small></li><li><a href="/categories/datadownload/">资料下载</a><small>1</small></li></ul></div><div class="widget tag"><h3 class="title">标签</h3><ul class="entry"><li><a href="/tags/content/">content</a><small>89</small></li><li><a href="/tags/library/">library</a><small>1</small></li><li><a href="/tags/machine-learning/">machine learning</a><small>22</small></li><li><a href="/tags/navigate/">navigate</a><small>1</small></li><li><a href="/tags/tools/">tools</a><small>3</small></li></ul></div><div class="widget tag"><h3 class="title">友情链接</h3><ul class="entry"><li><a href="http://blog.didispace.com" title="程序员DD">程序员DD</a></li><li><a href="https://mangoroom.cn" title="芒果的个人博客">芒果的个人博客</a></li><li><a href="http://www.baimin.com" target="_blank">百鸣网站百科</a></li><li><a href="http://blog.sina.com.cn/u/2435344920" target="_blank">默默读书</a></li><li><a href="https://www.jianshu.com/u/510007ddad06" target="_blank">王小鹏的随笔（简书）</a></li><li><a href="https://me.csdn.net/weixin_42438712" target="_blank">机器学习（csdn博客）</a></li><li><a href="https://zhuanlan.zhihu.com/c_1182309165824901120" target="_blank">机器学习（知乎）</a></li><li><a href="http://meixiaohan.com/" target="_blank">小寒大人的blog</a></li><li><a href="https://baippt.com/" target="_blank">ppt模板免费下载</a></li><li><a href="http://www.youneedcn.com/" target="_blank">你要的资源</a></li></ul></div></aside><div class="clearfix"></div></div><footer id="footer" class="inner"><div class="alignleft">&copy; 2020 王小鹏 京ICP备19037345号-1</div><div class="clearfix"></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></footer><script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">jQuery(".fancybox").fancybox()</script></body></html>